cmdhistory=["(foo)" "(foo 1)" "(foo \\"x\\")" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'scarabws.web)))" "scarabws.core/alldicts" "(keyword \\"foo\\")" "({\:foo \\"bar\\"} \:foo)" "(boolean 1)" "(boolean nil)" "(str \:foo)" "(\#\\"\\\\.txt\\" \\"foo.txt.bar\\"\\n          )" "(re-find \#\\"txt\\" \\"foo.txt.bar\\")" "(re-find \#\\".txt\\" \\"foo.txt.bar\\")" "(re-find \#\\"txt\\" \\"foo.tt.bar\\")" "(vector 1)" "(vector nil)" "concat" "(concat {\:a 1} {\:b 2})" "(union {\:a 1} {\:b 2})" "(merge {\:a 1} {\:b 2})" "(replace-re \#\\"\\\\.*\\" \\"\\" \\"foo.txt\\")" "(frequencies \\"abbaa\\")" "(sort < (frequencies \\"abbaa\\"))\\n1" "(map (fn [key val] (vector key val)) {\:a 1 \:b 2})" " (map (fn [key] (vector key)) {\:a 1 \:b 2})" "(map (fn [[key val]] (vector key val)) {\:a 1 \:b 2})" "(count \\"asb\\")" "(subvec [1 2 3 4] 0 2)" "(compare 1 2)" "({\:a 1 \:b 2} \:c)" "(or ({\:a 1 \:b 2} \:c) 0)" "(range 0 25)" "(compare [1] [2 3])" "(pop [1 2])" "(first [])" "(sort [[3] [1 2] []])" "(sort-by first compare [[3] [1 2] []])" "(sort-by first compare [[[3] \\"foo\\"] [[1 2] \\"bar\\"] [[] \\"baz\\"]])" "(sort-by first compare [[[3] \\"foo\\"] [[1 2] \\"bar\\"] [\\"baz\\"]])" "(sort-by first compare [[[3] [] \\"foo\\"] [[1 2] [] \\"bar\\"] [[] \\"baz\\"]])" "(sort-by first compare [[[3] [] \\"foo\\"] [[1 2] [] \\"bar\\"] [[8 8 8] \\"baz\\"]])" "(partition-by first [[1 2] [1 3] [2 5]])" "(first nil)" "(nth [1 2] 3)" "(map \#({\:foo 1 \:bar %}) [1 2 3])" "(map (fn [v] {\:foo 1 \:bar v}) [1 2 3])" ";; Switching to scarabws.run namespace" " (run-jetty \#'scarabws.web/app {\:port 8088})" "(compare nil 0)" "(sort [nil 1 2])" "({nil 1 2 3} nil)" "(into {} nil)" "(\#\\"[0-9]\\" \\"1\\")" "(re-matches \#\\"[0-9]\\" \\"1\\")" "(re-matches \#\\"[0-9]\\" \\"a1\\")" ";; Switching to scarabws.web namespace" "(re-matches \#\\"___|__[a-z]*_|_[a-z]*__|_[a-z]*_[a-z]*_\\" \\"foo\\")" "(re-matches \#\\"___|__[a-z]*_|_[a-z]*__|_[a-z]*_[a-z]*_\\" \\"f___oo\\")" "(re-matches \#\\"___|__[a-z]*_|_[a-z]*__|_[a-z]*_[a-z]*_\\" \\"___oo\\")" "(re-matches \#\\"___|__[a-z]*_|_[a-z]*__|_[a-z]*_[a-z]*_\\" \\"___\\")" "(re-matches \#\\"[a-z]*_[a-z]*_[a-z]*_[a-z]*\\" \\"___\\")" "(re-matches \#\\"[a-z]*_[a-z]*_[a-z]*_[a-z]*\\" \\"f___oo\\")" "(re-matches \#\\"[a-z]*_[a-z]*_[a-z]*_[a-z]*\\" \\"f_o__oo\\")" "(re-matches \#\\"[a-z]*_[a-z]*_[a-z]*_[a-z]*\\" \\"f_o__oo_\\")" "(re-matches \#\\"[a-z]*_[a-z]*_[a-z]*_[a-z_]*\\" \\"f_o__oo_\\")" "(re-matches \#\\"([a-z]*_){3,}[a-z_]*\\" \\"f_o__oo_\\")" "(re-matches \#\\"(?\:[a-z]*_){3,}[a-z_]*\\" \\"f_o__oo_\\")" "(re-matches \#\\"(?\:[a-z]*_){3,}[a-z_]*\\" \\"_o__oo\\")" " (re-matches \#\\"(?\:[a-z]*_){3,}[a-z_]*\\" \\"_o_oo\\")" "(re-matches \#\\"(?\:[a-z]*_){3,}\\" \\"f__o_oo\\")" "(concat (\:words {}) [])" "(reduce cons [1 2 3])" "(reduce vector [1 2 3])" "(reduce vector [1 2 3 4])" "(nil? {})" "(empty? {})" "(mapcat set [1 2 3])" "(set 1)" "(set [1])" "(mapcat (comp set vector) [1 2 3])" "(clojure.set/union \#{4} (mapcat (comp set vector) [1 2 3]))" "(clojure.set/union \#{4} nil (mapcat (comp set vector) [1 2 3]))" " (clojure.set/union \#{4} [5 6] (mapcat (comp set vector) [1 2 3]))" "(clojure.set/union \#{4} [5 6 5\\n                         ] (mapcat (comp set vector) [1 2 3]))" "(\= \\"foo\\" \\"foo\\")" "(set nil)" "\#{nil}" "(set [])" "(set 1\\n     )" "(set [1])" "(set [1] [2 3])" "(into (set [1]) [2 3])" "(frequency [1 1 2 15 15 15])" "(frequencies [1 1 2 15 15 15])" "(sorted-map (frequencies [1 1 2 15 15 15]))" "(apply sorted-map (frequencies [1 1 2 15 15 15]))" "(into [] (frequencies [1 1 2 15 15 15]))" "(into [] (frequencies [15 1 1 2 15 15 15]))" "(reduce cons [] [1 2 3 4])" "(reduce conj [] [1 2 3 4])" "(cons 1 [2])" "(range 1 0)" "(range 1 1)" "(- 5 2 1)"]
eclipse.preferences.version=1
